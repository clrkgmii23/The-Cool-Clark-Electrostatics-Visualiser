// this file is going to serve as a container for all the compute shader function that will be used
// in this program, and it should follow the convention of having a struct of an obeject defined,
// and right after it corrospoding function, ei its electric field, its magnetic field or potential.
// the struct needs to exist before the definitions, in order to generate the full compute shader 
// correctly. the end of a struct must end with "};" and a function must end with a single "}"

#version 430 core // these are here just to make the linter not red and angry
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

float k = 1;
float e_0 = 1;
float PI = 3.14159265359;

//											Point Charge								//
struct PointCharge{ // this will take 32 bytes
	vec3 position;
	float charge;
};
//
vec3 PointChargeElectricField(PointCharge pointcharge, vec3 gridPos){
	float r = distance(gridPos, pointcharge.position);
	if (r < 0.0001) return vec3(0);
	vec3 u = vec3(gridPos.x - pointcharge.position.x, gridPos.y - pointcharge.position.y,
	gridPos.z - pointcharge.position.z)/r;
	float E = k*pointcharge.charge/(r*r);
	return E*vec3(u);
}

//									  Infinite Charged Line								//

struct InfiniteChargedLine{ // this will take 32 bytes
	vec3 position;
	float charge;
};
//
vec3 InfiniteChargedLineElectricField(InfiniteChargedLine infiniteChargedLine, vec3 gridPos){
	// currently we'll only care about the x axis, TODO: 3D!
	float r = abs(gridPos.x - infiniteChargedLine.position.x);
	if (r < 0.0001) return vec3(0);
	vec3 u = normalize(vec3(gridPos.x - infiniteChargedLine.position.x, 0 ,0));
	float E = infiniteChargedLine.charge/(2*PI*e_0*r); 
	return E*vec3(u);
}


//											Charged Circle								//

struct ChargedCircle{ // this will take 32 bytes
	vec3 position;
	float charge;
	float radius;
};
//
vec3 ChargedCircleElectricField(ChargedCircle chargedcircle, vec3 gridPos){
	// E = Rdthtea/r^3 u
	vec3 E = vec3(0);
	vec3 E2 = vec3(0);
	float R = chargedcircle.radius;

	// integrating over the circle, approximation
	int N = 200; // number of segments
	float dTheta = 2*PI/N;
	for (int i = 0; i < N; i++){
		float theta = i*dTheta;
		vec3 u = vec3(	gridPos.x - chargedcircle.position.x - R*cos(theta),
						gridPos.y - chargedcircle.position.y - R*sin(theta),
						gridPos.z - chargedcircle.position.z);
		float r = length(u);
		if (r < 0.001) continue;
		E += R*dTheta/(r*r*r) * u;
	}
	return k*chargedcircle.charge * E;  // test difference
}