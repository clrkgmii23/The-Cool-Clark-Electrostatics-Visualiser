// this file is going to serve as a container for all the compute shader function that will be used
// in this program, and it should follow the convention of having a struct of an obeject defined,
// and right after it corrospoding function, ei its electric field, its magnetic field or potential.
// the struct needs to exist before the definitions, in order to generate the full compute shader 
// correctly. the end of a struct must end with "};" and a function must end with a single "}"

#version 430 core // these are here just to make the linter not red and angry
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

float k = 1;
float e_0 = 1;
float PI = 3.14159265359;

//											Point Charge								//
struct PointCharge{ // this will take 32 bytes
	vec3 position;
	float charge;
};
//
vec3 PointChargeElectricField(PointCharge pointcharge, vec3 gridPos){
	float r = distance(gridPos, pointcharge.position);
	if (r < 0.001) return vec3(0);
	vec3 u = vec3(gridPos.x - pointcharge.position.x, gridPos.y - pointcharge.position.y,
	gridPos.z - pointcharge.position.z)/r;
	float E = k*pointcharge.charge/(r*r);
	return E*vec3(u);
}

layout(binding = 0, std430) buffer positionBuffer {
        vec3 calculatedPos[];
};

int stepAmount = 10;
void PointChargeDistributePoints(PointCharge pointcharge, int i_abs, int i, int n){
	float theta = i * PI * (3-sqrt(5));
	float R = 0.05;
	float y = R*(1-float(i)/(n-1) * 2);
	float radius = sqrt(R*R-y*y);
	float x = radius * cos(theta);
	float z = radius * sin(theta);
	// get it there!!
	//float theta = i * PI * (3.0f - sqrt(5.0f));
	//float R = 0.05f;
	//float x = R * cos(theta);
	//float y = R * sin(theta);
	//float z = 0;
	calculatedPos[stepAmount*i_abs] = pointcharge.position + vec3(x, y, z);
}

//									  Infinite Charged Line								//

struct InfiniteChargedLine{ // this will take 32 bytes
	vec3 position;
	float charge;
};
//
vec3 InfiniteChargedLineElectricField(InfiniteChargedLine infiniteChargedLine, vec3 gridPos){
	vec3 vecFromLtoP = (gridPos - infiniteChargedLine.position);
	vecFromLtoP.y = 0;
	float r = length(vecFromLtoP);
	vec3 u = normalize(vecFromLtoP);
	if (r < 0.0001) return vec3(0);
	float E = infiniteChargedLine.charge/(2*PI*e_0*r); 
	return E*vec3(u);
}
void InfiniteChargedLineDistributePoints(InfiniteChargedLine infiniteChargedLine, int i_abs, int i, int n){
	
	calculatedPos[stepAmount*i_abs] = infiniteChargedLine.position + 0.01*vec3(cos(i*2*PI/n), 0, sin(i*2*PI/n));
}
//											Charged Circle								//

struct ChargedCircle{ // this will take 32 bytes
	vec3 position;
	float charge;
	float radius;
};
//
vec3 ChargedCircleElectricField(ChargedCircle chargedcircle, vec3 gridPos){
	// E = Rdthtea/r^3 u
	vec3 E = vec3(0);
	float R = chargedcircle.radius;

	// integrating over the circle, approximation
	int N = 200; // number of segments
	float dTheta = 2*PI/N;
	for (int i = 0; i < N; i++){
		float theta = i*dTheta;
		vec3 u = vec3(	gridPos.x - chargedcircle.position.x - R*cos(theta),
						gridPos.y - chargedcircle.position.y - R*sin(theta),
						gridPos.z - chargedcircle.position.z);
		float r = length(u);
		if (r < 0.001) continue;
		E += R*dTheta/(r*r*r) * u;
	}
	return k*chargedcircle.charge * E;  // test difference
}

void ChargedCircleDistributePoints(ChargedCircle chargedCircle, int i_abs, int i, int n){
	
	calculatedPos[stepAmount*i_abs] = chargedCircle.position + chargedCircle.radius *1.1 *vec3(cos(i*2*PI/n), sin(i*2*PI/n), 0);
}